/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "GPIO_Driver.h"
#include "RCC_Driver.h"
#include "SYSCONFIG_Driver.h"
#include "EXTI_Driver.h"
#include "NVIC_Driver.h"
#include "USART_Driver.h"

/*This RXBuff is used in USARTDemo Part19*/
uint8_t RxBuff[10];

GPIO_PINCONFIG_T RedLed =
{
		.pin = 14,
		.mode= GPIO_MODE_OUTPUT,
		.otype=GPIO_OTYPE_PP,
		.speed=GPIO_SPEED_LOW,
		.pupdr=GPIO_NO_PULL,
		.alternatefunc=0
};

GPIO_PINCONFIG_T PushButton =
{
		.pin = 0,
		.mode= GPIO_MODE_INPUT,
		.otype=GPIO_OTYPE_OD,
		.speed=GPIO_SPEED_LOW,
		.pupdr=GPIO_NO_PULL,
		.alternatefunc=0
};

USART_Struct_T Usart2Struct =
{
		.baudrate = 9600,
		.oversampling = 8,
		.parity = USART_PARITY_NONE,
		.stopBits = USART_STOPBITS_1,
		.usartID = USART2_ID,
		.wordLength = USART_WORDLENGTH_8B,
		.USARTInstance = USART2
};

void delay(void)
{
	for(uint32_t i=0; i< 1777777; i++);
}

void Part15_InterruptDemo()
{
	/*Enable Push Button Port Clock - Port A*/
	RCC_EnableGPIO(GPIOA);

	/*Enable LED Port Clock - Port D*/
	RCC_EnableGPIO(GPIOD);

	/*Initialize LED Pin*/
	GPIO_Init(GPIOD, &RedLed);

	/*Initialize PushButton Pin*/
	GPIO_Init(GPIOA, &PushButton);

	/*Set the EXTI0 to PA0 through SYSCFG*/
	SYSCFG_SetEXTISource(0,0);

	/*Enable EXTI Line Interrupt*/
	EXTI_EnableInterrupt(0, EXTI_TRIGGER_RISING);

	/*Enable NVIC Interrupt for EXTI0*/
	NVIC_EnableIRQ(EXTI0_IRQn);
}



void Part19_UARTDemo(void)
{
	const char *message = "Hello from USART2!\n";
	//Enable FPU
	SCB_CPACR_ADDR |= (0xF << 20);

	//Enable the HSE Clock (8MHz) and configure the USART Peripheral Clock (APB Clock) also to 8MHz
	RCC_Config_HSE_SystemClock();

	USART_Init(&Usart2Struct);
	USART_Transmit(&Usart2Struct, (uint8_t*)message, 19);
	while(1)
	{
		USART_Receive(&Usart2Struct, (uint8_t*)RxBuff, 1);
		USART_Transmit(&Usart2Struct, (uint8_t*)RxBuff, 1);
	}
}

void Part20_UARTDemo(void)
{
	const char *message = "Hello from USART2!\n";
	//Enable FPU
	SCB_CPACR_ADDR |= (0xF << 20);

	//Enable the HSE Clock (8MHz) and configure the USART Peripheral Clock (APB Clock) also to 8MHz
	RCC_Config_HSE_SystemClock();

	USART_Init(&Usart2Struct);

	//Enable NVIC Module USART2 Interrupt
	NVIC_EnableIRQ(USART2_IRQn);
	USART_Transmit_IT(&Usart2Struct, (uint8_t*)message, 19);
	USART_Receive_IT(&Usart2Struct, (uint8_t*)RxBuff, 1);

	while(1)
	{
		if(Usart2Struct.RxBusy == 0)
		{
			USART_Transmit_IT(&Usart2Struct, (uint8_t*)RxBuff, 1);
			USART_Receive_IT(&Usart2Struct, (uint8_t*)RxBuff, 1);
		}
	}
}

int main(void)
{
	/*Uncomment to execute Interrupt Demo*/
	//Part15_InterruptDemo();

	/*Uncomment to execute UART Demo for Part19*/
	//Part19_UARTDemo();

	Part20_UARTDemo();
}



void EXTI0_IRQHandler()
{
	if(EXTI_IsPending(0) == 1)
	{
		GPIO_TogglePin(GPIOD, 14);
		EXTI_ClearPending(0);
	}
}

void USART2_IRQHandler()
{
	//Transmit the data in Interrupt mode
	if((Usart2Struct.USARTInstance->SR & USARTx_SR_TXE) &&
	   (Usart2Struct.USARTInstance->CR1 & USARTx_CR1_TXEIE))
	{
		if(Usart2Struct.TxIndex < Usart2Struct.TxLength)
			Usart2Struct.USARTInstance->DR = Usart2Struct.pTxBuffer[Usart2Struct.TxIndex++];
		else
		{
			Usart2Struct.USARTInstance->CR1 &= ~(USARTx_CR1_TXEIE);
			Usart2Struct.TxBusy =0;
		}
	}

	//Receive the data in Interrupt mode
	if((Usart2Struct.USARTInstance->SR & USARTx_SR_RXNE) &&
	   (Usart2Struct.USARTInstance->CR1 & USARTx_CR1RXNEIE))
	{
		Usart2Struct.pRxBuffer[Usart2Struct.RxIndex++] = Usart2Struct.USARTInstance->DR & 0xFF;

		if(Usart2Struct.RxIndex >= Usart2Struct.RxLength)
		{
			Usart2Struct.USARTInstance->CR1 &= ~(USARTx_CR1RXNEIE);
			Usart2Struct.RxBusy = 0;
		}

	}

}

